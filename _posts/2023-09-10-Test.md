---
toc: true
comments: true
layout: post
title: TEST
description:  This is level 2 in our game. This is how it looks separately. This is Midnight Ninja.
courses: { compsci: {week: 2} }
type: hacks
---
---
toc: true
comments: true
layout: post
title: Midnight Stalker Animation
description:  This is level 2 in our game. This is how it looks separately. This is Midnight Ninja.
courses: { compsci: {week: 2} }
type: hacks
---

<body>
    <div>
        <canvas id="spriteContainer"> <!-- Within the base div is a canvas. An HTML canvas is used only for graphics. It allows the user to access some basic functions related to the image created on the canvas (including animation) -->
            <img id="ninjaSprite" src="{{site.baseurl}}/images/midnightStalker.png"> 
        </canvas>
        <div id="controls"> <!--basic radio buttons which can be used to check whether each individual animation works -->
            <input type="radio" name="animation" id="A">
            <label for="walking">Jumping</label><br>
            <input type="radio" name="animation" id="B">
            <label for="walking">Sword Fighting</label><br>
            <input type="radio" name="animation" id="C">
            <label for="walking">Sword Strikes</label><br>
            <button id="throwBomb">Throw Bomb</button> <!-- Added a button to trigger bomb throwing -->
        </div>
    </div>
    <script>
        // start on page load
        window.addEventListener('load', function () {
            const canvas = document.getElementById('spriteContainer');
            const ctx = canvas.getContext('2d');
            const SPRITE_WIDTH = 30;  // matches sprite pixel width
            const SPRITE_HEIGHT = 30; // matches sprite pixel height
            const SCALE_FACTOR = 3;  // control size of sprite on canvas
            const FRAME_LIMIT = 5;  // number of frames per row, this code assumes each row is the same
            const DESIRED_FRAME_RATE = 8; // 8 frames per second
            const FRAME_INTERVAL = 1000 / DESIRED_FRAME_RATE;
            const BOMB_RADIUS = 5; // radius of the bomb
            const BOMB_SPEED = 20; // speed of the bomb
            const BOMB_DISTANCE = 200; // distance before bomb disappears
            const EXPLOSION_DURATION = 3000; // duration of the explosion in milliseconds
            const EXPLOSION_FRAME_LIMIT = 3; // number of frames for the explosion animation
            const EXPLOSION_FRAME_INTERVAL = EXPLOSION_DURATION / EXPLOSION_FRAME_LIMIT;
            canvas.width = SPRITE_WIDTH * SCALE_FACTOR * 8;
            canvas.height = SPRITE_HEIGHT * SCALE_FACTOR;
            class Ninja {
                constructor() {
                    this.image = document.getElementById("ninjaSprite");
                    this.spriteWidth = SPRITE_WIDTH;
                    this.spriteHeight = SPRITE_HEIGHT;
                    this.width = this.spriteWidth;
                    this.height = this.spriteHeight;
                    this.x = 0; // Initial x position
                    this.y = 0;
                    this.scale = SCALE_FACTOR;
                    this.minFrame = 0;
                    this.maxFrame = FRAME_LIMIT;
                    this.frameX = 0;
                    this.frameY = 0;
                    this.velocityX = 6; // Horizontal velocity
                }
                // draw ninja object
                draw(context) {
                    context.drawImage(
                        this.image,
                        this.frameX * this.spriteWidth,
                        this.frameY * this.spriteHeight,
                        this.spriteWidth,
                        this.spriteHeight,
                        this.x,
                        this.y,
                        this.width * this.scale,
                        this.height * this.scale
                    );
                }
                // update frameX of ninja object
                update() {
                    if (this.frameX < this.maxFrame) {
                        this.frameX++;
                    } else {
                        this.frameX = 0;
                    }
                    // Update x position for horizontal movement
                    this.x += this.velocityX;
                    // Reset x position if it goes beyond the canvas
                    if (this.x > canvas.width) {
                        this.x = -this.width * this.scale;
                    }
                }
            }
            class Bomb {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.radius = BOMB_RADIUS;
                    this.speed = BOMB_SPEED;
                    this.distanceTravelled = 0; // to track the distance the bomb has traveled
                    this.isExploding = false;
                    this.explosionFrame = 0;
                }
                draw(context) {
                    if (this.isExploding) {
                        // Draw explosion animation
                        context.drawImage(
                            this.image,
                            this.explosionFrame * this.spriteWidth,
                            4 * this.spriteHeight, // Assuming explosion frames start at the 5th row
                            this.spriteWidth,
                            this.spriteHeight,
                            this.x - this.radius * SCALE_FACTOR,
                            this.y - this.radius * SCALE_FACTOR,
                            this.radius * 2 * SCALE_FACTOR,
                            this.radius * 2 * SCALE_FACTOR
                        );
                    } else {
                        // Draw bomb
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                        context.fillStyle = 'black';
                        context.fill();
                        context.closePath();
                    }
                }
                update() {
                    if (this.isExploding) {
                        this.explosionFrame++;
                        if (this.explosionFrame >= EXPLOSION_FRAME_LIMIT) {
                            // End explosion animation
                            this.isExploding = false;
                        }
                    } else {
                        this.x += this.speed;
                        this.distanceTravelled += this.speed;
                        // Check if the bomb has reached the explosion point
                        if (this.distanceTravelled >= BOMB_DISTANCE) {
                            // Start explosion animation
                            this.isExploding = true;
                            this.explosionFrame = 0;
                        }
                    }
                }
            }
            // ... (unchanged)
            const ninja = new Ninja();
            // bombs array
            const bombs = [];
            // update frameY of ninja object, action from idle, bark, walk radio control
            const controls = document.getElementById('controls');
            controls.addEventListener('click', function (event) {
                if (event.target.tagName === 'INPUT') {
                    const selectedAnimation = event.target.id;
                    switch (selectedAnimation) {
                        case 'A':
                            ninja.frameY = 2;
                            break;
                        case 'B':
                            ninja.frameY = 5;
                            break;
                        case 'C':
                            ninja.frameY = 6;
                            break;
                    }
                }
            });
            // throw bomb button
            const throwBombButton = document.getElementById('throwBomb');
            throwBombButton.addEventListener('click', function () {
                const bomb = new Bomb(ninja.x + ninja.width * ninja.scale, ninja.y + ninja.height * ninja.scale / 2);
                bombs.push(bomb);
            });
            let lastTimestamp = 0;
            function animate(timestamp) {
                const deltaTime = timestamp - lastTimestamp;
                if (deltaTime >= FRAME_INTERVAL) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ninja.draw(ctx);
                    ninja.update();
                    bombs.forEach(bomb => {
                        bomb.draw(ctx);
                        bomb.update();
                    });
                    lastTimestamp = timestamp;
                }
                requestAnimationFrame(animate);
            }
            animate();
        });
    </script>
</body>
